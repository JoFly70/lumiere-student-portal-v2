/**
 * Student Repository
 * Data access layer for student profile operations using Drizzle ORM
 * Used in demo mode when ALLOW_DEMO_MODE=true
 * 
 * Serialization: Drizzle returns Date objects for timestamp columns,
 * but the API types expect ISO datetime strings (matching Supabase).
 * Serialization helpers convert Date â†’ ISO string for API consistency.
 */

import { db } from '../lib/db';
import { 
  studentsTable, 
  studentContactsTable, 
  studentEnglishProofTable 
} from '@shared/schema';
import { eq } from 'drizzle-orm';
import { logger } from '../lib/logger';
import type { 
  Student, 
  InsertStudent, 
  StudentsTableSelect,
  StudentContact,
  InsertStudentContact,
  StudentContactsTableSelect,
  EnglishProof,
  InsertEnglishProof,
  StudentEnglishProofTableSelect
} from '@shared/schema';

/**
 * Serialize Drizzle student row to Student type
 * Converts Date objects to ISO strings for API consistency
 */
function serializeStudent(row: StudentsTableSelect): Student {
  return {
    ...row,
    // Convert Date objects to ISO strings
    created_at: row.created_at.toISOString(),
    updated_at: row.updated_at.toISOString(),
    email_verified_at: row.email_verified_at?.toISOString() || null,
    consent_signed_at: row.consent_signed_at?.toISOString() || null,
    // Date fields (dob, start_term) are already strings from Drizzle
  } as Student;
}

/**
 * Get student by ID
 */
export async function getStudentById(studentId: string): Promise<Student | null> {
  try {
    const result = await db
      .select()
      .from(studentsTable)
      .where(eq(studentsTable.id, studentId))
      .limit(1);

    if (!result || result.length === 0) {
      return null;
    }

    return serializeStudent(result[0]);
  } catch (error) {
    logger.error('Error getting student by ID', { studentId, error });
    throw error;
  }
}

/**
 * Get student by user ID
 */
export async function getStudentByUserId(userId: string): Promise<Student | null> {
  try {
    const result = await db
      .select()
      .from(studentsTable)
      .where(eq(studentsTable.user_id, userId))
      .limit(1);

    if (!result || result.length === 0) {
      return null;
    }

    return serializeStudent(result[0]);
  } catch (error) {
    logger.error('Error getting student by user ID', { userId, error });
    throw error;
  }
}

/**
 * Get student by student code
 */
export async function getStudentByCode(studentCode: string): Promise<Student | null> {
  try {
    const result = await db
      .select()
      .from(studentsTable)
      .where(eq(studentsTable.student_code, studentCode))
      .limit(1);

    if (!result || result.length === 0) {
      return null;
    }

    return serializeStudent(result[0]);
  } catch (error) {
    logger.error('Error getting student by code', { studentCode, error });
    throw error;
  }
}

/**
 * Create new student profile
 * Note: student_code will be auto-generated by database trigger
 */
export async function createStudent(studentData: InsertStudent): Promise<Student> {
  try {
    const result = await db
      .insert(studentsTable)
      .values(studentData as any)
      .returning();

    if (!result || result.length === 0) {
      throw new Error('Failed to create student');
    }

    logger.info('Student profile created', { 
      studentId: result[0].id, 
      studentCode: result[0].student_code 
    });

    return serializeStudent(result[0]);
  } catch (error) {
    logger.error('Error creating student', { error });
    throw error;
  }
}

/**
 * Update student profile
 */
export async function updateStudent(
  studentId: string, 
  updates: Partial<InsertStudent>
): Promise<Student> {
  try {
    const result = await db
      .update(studentsTable)
      .set(updates as any)
      .where(eq(studentsTable.id, studentId))
      .returning();

    if (!result || result.length === 0) {
      throw new Error('Student not found or update failed');
    }

    logger.info('Student profile updated', { studentId });

    return serializeStudent(result[0]);
  } catch (error) {
    logger.error('Error updating student', { studentId, error });
    throw error;
  }
}

/**
 * Update student photo URL
 */
export async function updateStudentPhoto(
  studentId: string,
  photoUrl: string | null
): Promise<Student> {
  try {
    const result = await db
      .update(studentsTable)
      .set({ photo_url: photoUrl })
      .where(eq(studentsTable.id, studentId))
      .returning();

    if (!result || result.length === 0) {
      throw new Error('Student not found');
    }

    logger.info('Student photo updated', { studentId, photoUrl });

    return serializeStudent(result[0]);
  } catch (error) {
    logger.error('Error updating student photo', { studentId, error });
    throw error;
  }
}

// ============================================================================
// Student Contacts Repository
// ============================================================================

/**
 * Serialize Drizzle student contact row to StudentContact type
 */
function serializeStudentContact(row: StudentContactsTableSelect): StudentContact {
  return {
    ...row,
    created_at: row.created_at.toISOString(),
  } as StudentContact;
}

/**
 * Get all contacts for a student
 */
export async function getStudentContacts(studentId: string): Promise<StudentContact[]> {
  try {
    const result = await db
      .select()
      .from(studentContactsTable)
      .where(eq(studentContactsTable.student_id, studentId));

    return result.map(serializeStudentContact);
  } catch (error) {
    logger.error('Error getting student contacts', { studentId, error });
    throw error;
  }
}

/**
 * Add new student contact
 */
export async function addStudentContact(
  studentId: string,
  contactData: Omit<InsertStudentContact, 'student_id'>
): Promise<StudentContact> {
  try {
    const result = await db
      .insert(studentContactsTable)
      .values({
        ...contactData,
        student_id: studentId,
      } as any)
      .returning();

    if (!result || result.length === 0) {
      throw new Error('Failed to create contact');
    }

    logger.info('Student contact added', { studentId, contactId: result[0].id });

    return serializeStudentContact(result[0]);
  } catch (error) {
    logger.error('Error adding student contact', { studentId, error });
    throw error;
  }
}

/**
 * Update student contact
 */
export async function updateStudentContact(
  contactId: string,
  updates: Partial<Omit<InsertStudentContact, 'student_id'>>
): Promise<StudentContact> {
  try {
    const result = await db
      .update(studentContactsTable)
      .set(updates as any)
      .where(eq(studentContactsTable.id, contactId))
      .returning();

    if (!result || result.length === 0) {
      throw new Error('Contact not found');
    }

    logger.info('Student contact updated', { contactId });

    return serializeStudentContact(result[0]);
  } catch (error) {
    logger.error('Error updating student contact', { contactId, error });
    throw error;
  }
}

/**
 * Delete student contact
 */
export async function deleteStudentContact(contactId: string): Promise<void> {
  try {
    const result = await db
      .delete(studentContactsTable)
      .where(eq(studentContactsTable.id, contactId))
      .returning();

    if (!result || result.length === 0) {
      throw new Error('Contact not found');
    }

    logger.info('Student contact deleted', { contactId });
  } catch (error) {
    logger.error('Error deleting student contact', { contactId, error });
    throw error;
  }
}

// ============================================================================
// English Proof Repository
// ============================================================================

/**
 * Serialize Drizzle English proof row to EnglishProof type
 */
function serializeEnglishProof(row: StudentEnglishProofTableSelect): EnglishProof {
  return {
    ...row,
    created_at: row.created_at.toISOString(),
    updated_at: row.updated_at.toISOString(),
  } as EnglishProof;
}

/**
 * Get English proof for a student
 */
export async function getEnglishProof(studentId: string): Promise<EnglishProof | null> {
  try {
    const result = await db
      .select()
      .from(studentEnglishProofTable)
      .where(eq(studentEnglishProofTable.student_id, studentId))
      .limit(1);

    if (!result || result.length === 0) {
      return null;
    }

    return serializeEnglishProof(result[0]);
  } catch (error) {
    logger.error('Error getting English proof', { studentId, error });
    throw error;
  }
}

/**
 * Upsert English proof (create or update)
 */
export async function upsertEnglishProof(
  studentId: string,
  proofData: Omit<InsertEnglishProof, 'student_id'>
): Promise<EnglishProof> {
  try {
    // Check if exists
    const existing = await getEnglishProof(studentId);

    if (existing) {
      // Update existing
      const result = await db
        .update(studentEnglishProofTable)
        .set({
          ...proofData,
          updated_at: new Date(),
        } as any)
        .where(eq(studentEnglishProofTable.student_id, studentId))
        .returning();

      logger.info('English proof updated', { studentId });

      return serializeEnglishProof(result[0]);
    } else {
      // Create new
      const result = await db
        .insert(studentEnglishProofTable)
        .values({
          ...proofData,
          student_id: studentId,
        } as any)
        .returning();

      logger.info('English proof created', { studentId });

      return serializeEnglishProof(result[0]);
    }
  } catch (error) {
    logger.error('Error upserting English proof', { studentId, error });
    throw error;
  }
}
